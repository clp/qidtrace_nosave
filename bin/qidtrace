#! /usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;

use Sendmail::QidTrace qw/match_line/;

our $VERSION = '0.02';
our @matching_qids;  # TBD: Global var used in match_line().

my $DEBUG = 0;    # Set to 1 to enable debug stmts.
                  # Set to 0 to run tests & for normal operation.


my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any
my $window_size = 100;
$window_size = 1 if $DEBUG;  #DBG
my $email_address;
my $emit_line_numbers = 0;
my $output_start_column = 0;
my $output_length       = 0;  # default to the whole line

unless (GetOptions(
            # input matching
            'window-size=i' => \$window_size,
            'match-pattern=s' => \$email_address,
            # output formatting
            'number-output' => \$emit_line_numbers,
            # control what part of the match line we emit by calls to substr
            'start-column=i'  => \$output_start_column,
            'output-length=i' => \$output_length)) {
    die usage();
}
unless ($email_address) {
    die "$prog died: No email address found on command line\n\n", usage();
}

my $qt = new Sendmail::QidTrace::Queue({match        => $email_address,
                                        window_size  => $window_size,
                                        line_numbers => $emit_line_numbers});
while (<>) {
    chomp;
    my $line;
    my $num;
    $qt->push_onto_leading_array($_);
      #TBR? {   num  => $.,  #TBD: Use $qt for num instead of hash here?
      #TBR? line => $_
      #TBR? }
    #TBR? );

    #DBG print "DBG.while: \$.: ,$.,\n" if ($DEBUG);

    # Fill the _leading array before checking for matches.
    if ( $qt->size_of_leading_array > $window_size ) {

        my $line = $qt->shift_off_leading_array();  #TBD: Keep or use hash from @_leading?

        my ($match_email, $match_qid) = match_line($email_address, $line);
        if ($match_email || $match_qid) {
            $qt->add_match({match => $match_email,
                            qid   => $match_qid,
                            line  => ($output_length
                                      ? substr($line, $output_start_column, $output_length)
                                      : substr($line, $output_start_column)),
                            num   => $. });
        }

        # Check buffer for matching qid's.
        #TBD.

        # Print all the lines stored in %_seen.
        #TBD.
        #TBD print_matching_lines();  #TBD?: if (keys %_seen)
        print_matching_lines()  if ($qt->get_seen_hash);

        # Erase content of %_seen.
        #TBD.
        $qt->erase_seen_hash();

    }  # End if (leading array > window_size )
}  # End while()
# $qt->drain_queue();


# Print all matching lines from the %_seen hash.
sub print_matching_lines {
    foreach my $k ( sort keys %{ $qt->get_seen_hash } ) {
        #TBF: Specifying cmd line param '-s' can affect the sorted o/p.  Fix this.
        my $h = shift( @{ ${ $qt->get_seen_hash }{$k} } );
        print "${$h}{num}; " if ($emit_line_numbers);
        print "${$h}{line}\n";

        foreach ( @{ ${ $qt->get_seen_hash }{$k} } ) {
            print "**** ";
            print "${$_}{num}; " if ($emit_line_numbers);
            print "${$_}{line}\n";
        }
    }
}




# =begin comment

# Print all matching lines from the %_seen hash.
sub print_matching_lines_0_HASH {
    foreach my $k ( sort keys %{ $qt->get_seen_hash } ) {
        #TBF: Specifying cmd line param '-s' can affect the sorted o/p.  Fix this.
        my $h = shift( @{ ${ $qt->get_seen_hash }{$k} } );
        print "${$h}{num}; " if ($emit_line_numbers);
        print "${$h}{line}\n";

        foreach ( @{ ${ $qt->get_seen_hash }{$k} } ) {
            print "**** ";
            print "${$_}{num}; " if ($emit_line_numbers);
            print "${$_}{line}\n";
        }
    }
}

# =end comment

# =cut



=pod

=head2 Print All Matching Lines

Use two loops to print the collection of o/p lines, grouped 
and sorted by qid.

The outer loop dereferences the hash ref,
  selects the keys (which are qid's),
  sorts the list by qid,
  then iterates over its block using each qid as the index value.
  The first entry is extracted from the AoH & printed.

The inner loop takes the qid as a key for the %_seen hash,
  gets the hash value for that key (which is a ref to an array),
  dereferences the array,
  iterates over every member of that array,
  dereferences the entry, which is a hash ref,
  extracts the values for line number and line,
  and prints those two values.

=cut



exit;

sub usage {
    return <<"eousage";
usage $prog: [options] -m match_string <log_files>

$prog is a filter for sendmail log files.
It follows sendmails queue id strings so that sequences of log lines can be found.

Options to control the matching

-match-pattern string    log lines are matched against this literal (not regex) pattern.
                         typical usage is an email address, or a virus name.
                         Required.

-window-size   int       a window of log lines both in front of, and behind the current line
                         is kept.  Matches will be found in this buffer.
                         Default: 100

Output options

-number-output  flag     emit the line number of the matching line on output

-start-column   int      Control what portion of the matching line is displayed.
                         start-column gives the first column of the output line displayed.
-output-length  int      Length of the output line before line numbering, if any.
eousage
}

